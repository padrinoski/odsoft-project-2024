properties([
    parameters([
        choice(
            name: 'ENV',
            choices: ['development', 'testing', 'production'],
            description: 'Select the environment for deployment'
        )
    ])
])


node {
    def DOCKER_CREDENTIALS_ID = 'docker-hub-credentials'
    def DOCKER_IMAGE = 'books-c-image'
    def DOCKER_REGISTRY = 'hellensantos'
    def DOCKERFILE_PATH = 'P2/apps/Books/BooksC/Dockerfile'
    def STACK_NAME = "books-command-${params.ENV}"
    def COMPOSE_FILE = 'P2/docker-swarm/books-command.yml'
    def CONFIG_FILE = "P2/docker-swarm/config.sh"
    def BOOKS_COMMAND_DATABASE_IMAGE = ''
    def BOOKS_COMMAND_DATABASE_TO_USE = ''
    def BOOKS_COMMAND_DB_PORT = ''
    def ID_GENERATOR = ''
    def RECOMMENDATION_ALGORITHM = ''
    def RECOMMENDATION_X = ''
    def RECOMMENDATION_Y = ''
    def MINIMUM_AGE = ''
    def MAXIMUM_AGE = ''
    env.ENV_FILE = "${params.ENV}.env"


    try {
        stage('Checkout') {
            echo "Checking out source code"
            checkout([$class: 'GitSCM', branches: [[name: '*/main']], userRemoteConfigs: [[url: 'https://github.com/padrinoski/odsoft-project-2024.git']]])
        }

        stage('Build') {
            echo "Building Docker image ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${params.ENV}"
            // Specify the environment file if needed (e.g., for development or production)
            def envFile = "P2/docker-swarm/${params.ENV}.env"
            sh "echo Using environment file: ${envFile}"

            // Build the Docker image with the appropriate environment file
            def image = docker.build(
                "${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${params.ENV}",
                "--build-arg ENV_FILE=${envFile} -f ${DOCKERFILE_PATH} P2/apps/Books/BooksC"
            )
        }

        stage('Push') {
            echo "Pushing Docker image to ${DOCKER_REGISTRY}"
            docker.withRegistry("", DOCKER_CREDENTIALS_ID) {
                docker.image("${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${params.ENV}").push()
            }
        }
        stage('Load Config'){
            // Read and parse the config file
            def config = sh(script: """#!/bin/bash
                . ${CONFIG_FILE}
                echo "BOOKS_COMMAND_DATABASE_IMAGE=\$BOOKS_COMMAND_DATABASE_IMAGE"
                echo "BOOKS_COMMAND_DATABASE_TO_USE=\$BOOKS_COMMAND_DATABASE_TO_USE"
                echo "BOOKS_COMMAND_DB_PORT=\$BOOKS_COMMAND_DB_PORT"
                echo "ID_GENERATOR=\$ID_GENERATOR"
                echo "RECOMMENDATION_ALGORITHM=\$RECOMMENDATION_ALGORITHM"
                echo "RECOMMENDATION_X=\$RECOMMENDATION_X"
                echo "RECOMMENDATION_Y=\$RECOMMENDATION_Y"
                echo "MINIMUM_AGE=\$MINIMUM_AGE"
                echo "MAXIMUM_AGE=\$MAXIMUM_AGE"
            """, returnStdout: true).trim()
            
            // Parse the output and set environment variables
            config.split('\n').each { line ->
                def (key, value) = line.split('=')
                env[key] = value
            }
        }

        stage('Debug') {
            echo "BOOKS_COMMAND_UPDATE_PARALLELISM: ${env.BOOKS_COMMAND_UPDATE_PARALLELISM}"
            echo "BOOKS_COMMAND_UPDATE_DELAY: ${env.BOOKS_COMMAND_UPDATE_DELAY}"
            
            echo "Checking if the .env file exists"
            sh 'if [ -f P2/docker-swarm/development.env ]; then echo "File exists"; else echo "File not found"; fi'
        }

        stage('Load Environment Variables') {
            echo "Loading environment variables from ${params.ENV}.env"
            sh '''
                # Check if the file exists
                if [ -f P2/docker-swarm/$ENV.env ]; then
                    echo "File exists, loading environment variables..."
                    # Export variables from the file, ignore lines starting with #
                    while IFS= read -r line; do
                        # Skip empty lines and comments
                        if [[ ! "$line" =~ ^# && -n "$line" ]]; then
                            export "$line"
                        fi
                    done < P2/docker-swarm/$ENV.env
                else
                    echo "File P2/docker-swarm/$ENV.env not found!"
                    exit 1
                fi
                
                # Print environment variables
                echo "Environment variables loaded:"
                printenv
            '''
        }


        stage('Deploy') {
            echo "Deploying with Docker stack"
            
            // Ensure the compose file exists
            sh "test -f ${COMPOSE_FILE} || (echo 'Compose file not found' && exit 1)"
            
            // Deploy the stack
            sh """
                docker stack deploy \
                    --with-registry-auth \
                    -c ${COMPOSE_FILE} \
                    ${STACK_NAME}
            """
            
            // Wait for services to be running
            sh """
                # Wait for service to be updated
                ATTEMPTS=0
                MAX_ATTEMPTS=30
                until docker stack services ${STACK_NAME} | grep -q '1/1' || [ \$ATTEMPTS -eq \$MAX_ATTEMPTS ]; do
                    echo "Waiting for services to be ready..."
                    sleep 10
                    ATTEMPTS=\$((ATTEMPTS+1))
                done
                
                if [ \$ATTEMPTS -eq \$MAX_ATTEMPTS ]; then
                    echo "Service deployment timed out"
                    exit 1
                fi
            """
        }

        stage('Test') {
            echo "Running tests (to be implemented)"
            // Add your test logic here
        }

    } catch (Exception e) {
        currentBuild.result = 'FAILURE'
        echo "Build failed: ${e.message}"
        throw e
    } finally {
        stage('Cleanup') {
            echo 'Cleaning up Docker system'
            // deleteDir()
            sh 'docker system prune -f'
        }
    }
}